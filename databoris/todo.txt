
== launcher kernel

 - script bootstrapping 
 - serialization
 - configuration, eg read settings from somehwhere (exe-name.lua file?)
 - networking (socket client)
 - client-server protocol 	
 - error messages (messagebox, popups)
 - command line parsing
 - 
 - caching, eg libgit for storage

=== script bootstrapping

 - storage of lua scripts inside the launcher executable
 - implement link() function to load from launcher?
  
local codec = link(688) -- dostring (cached) from resource 688
  

=== serialization format

 - structure like binson, very targeted format
 - should support table,string,double,integer,boolean
 
          MSN      LSN  
        +--------------------------------------------------+
null    | 0 0 0 0  0 0 0 0 | N/A               | N/A       |
true    | 0 0 0 0  0 0 0 1 | N/A               | N/A       |
false   | 0 0 0 0  0 0 1 0 | N/A               | N/A       |
int64   | 0 0 0 0  0 0 1 1 | value (8 bytes)   | N/A       |
double  | 0 0 0 0  0 1 0 0 | value (8 bytes)   | N/A       |
object  | x x 0 0  1 0 0 0 | len (num pairs)   | len pairs | 
array   | x x 0 0  1 0 0 1 | len (num elems)   | len elems |
string  | x x 0 0  1 0 1 0 | len (num bytes)   | len bytes |
int32   | x x 0 0  1 0 1 1 | value (len bytes) | N/A       |
raw     | x x 0 0  1 1 0 0 | len (num bytes)   | len bytes |
        +--------------------------------------------------+

nil=0x0
true=0x1
false=0x2


- implement encode/decode to memory buffer
- stream impl via table

=== configuration

 - ini file?
 - config items
 	- known databases
 		home=beast:5060
 	- network params
 		socket,timeouts,dns
 	- logging
 		logdir/name
 	- update details?
 	
=== networking

 - streaming (can it be done with chunks in a table? YES)
 - clients
 	- send block/stream
 	- receive block/stream
 - server
 	- socket select
 	- coroutine for handles
 	- libuv for fast network stack
 - messaging
 	- equivalent of rabbitmq, zeromq
 	- may be able to use 0mq directly as a library?
 
=== client server procotol

 - send:
 - magic byte
 	- version byte
 	- command name (string)
 	- command args (table)
 - receive
 	- magic byte
 	- version byte
 	- table
      - return code
 	  - error
 	  - result (any)		
 - exceptions/errors?
 	
=== caching?
	
 - can this code be on the server?

=== deployment

- can we use the name of the executable as a lookup into a script/config
  on the sourcedb. 
  
=== runtime

- need a management system for DLLs. ideally we want to be able to stream
  in the DLL from the source server based on our bootstrap requirements
- can we store DLLs as hashes? 
- might be easier just to version number them and record their dependencies
- eg build a manifest for the DLL (ala ivy modules)
- hook the LoadLibrary function to plug in the right DLL based on our manifest
- might want a built in way to clean up stale/old files


 %TEMP%/space for application - how to organize...
 
- may need a central/app specific cache of blobs under %TEMP%
- this can be a form of system update 

=== UI

 - UI widgets are different views/editors of tables
 	 - containers are resursive holders of other widgets
 	 - layouts?
 	 
  - compound layouts, eg higher level desc of widget tree
  
  
  - can we just embed chromium?
  		- and then embed the text,table editors as plugins?
  - convert from css,html,javascript to internal format?
  - transcoding from javascript to lua as a way to implement a fast browser?
 
=== Library plugins

	- chromium
	- vlc library (embed videos)
	- git
	- wifi/bluetooth 
	- scintilla? editor
	
 